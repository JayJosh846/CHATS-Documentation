"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Queue = void 0;
const amqp_ts_1 = require("../amqp-ts");
const Binding_1 = require("../Binding");
const Message_1 = require("../Message");
/** Represents an AQMP queue. */
class Queue {
    /** Returns the name of the queue. */
    get name() {
        return this._name;
    }
    /**
     * Initializes a new instance of the @see Queue class.
     *
     * @summary Waits until the given connection is initialized, then creates a channel on it and declares a queue with
     * the given name.
     * @param connection The AMQP connection.
     * @param name The name of the queue.
     * @param options Any queue declaring options.
     * @constructor
     */
    constructor(connection, name, options = {}) {
        this.connection = connection;
        this.options = options;
        this.log = this.connection.loggerFactory(this.constructor, { queue: name });
        this._name = name;
        this.connection._queues[this._name] = this;
        this._initialize();
    }
    /** Waits until the connection is initialized then creates a channel and declares the queue on it. */
    _initialize() {
        this.initialized = new Promise((resolve, reject) => {
            this.connection.initialized
                .then(() => {
                this.connection.connection.createChannel((createChannelError, channel) => {
                    /* istanbul ignore if */
                    if (createChannelError) {
                        reject(createChannelError);
                    }
                    else {
                        this._channel = channel;
                        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                        this._channel.on("delivery", this.handleReceivedMessageEvent.bind(this));
                        const callback = (err, ok) => {
                            /* istanbul ignore if */
                            if (err) {
                                this.log.error({ error: err }, "Failed to create queue '%s'.", this._name);
                                delete this.connection._queues[this._name];
                                reject(err);
                            }
                            else {
                                if (this.options.prefetch) {
                                    this._channel.prefetch(this.options.prefetch);
                                }
                                resolve(ok);
                            }
                        };
                        if (this.options.noCreate) {
                            this._channel.checkQueue(this._name, callback);
                        }
                        else {
                            this._channel.assertQueue(this._name, this.options, callback);
                        }
                    }
                });
            })
                .catch((err) => {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                this.log.warn(err, "Channel failure, error caused during connection!");
            });
        });
    }
    /**
     * Directly sends a message to the underlying queue.
     *
     * @param message The AMQP message.
     */
    send(message) {
        message.sendTo(this);
    }
    rpc(requestParameters) {
        return new Promise((resolve, reject) => {
            const processRpc = () => {
                let consumerTag;
                this._channel.consume(amqp_ts_1.DIRECT_REPLY_TO_QUEUE, (resultMsg) => {
                    this._channel.cancel(consumerTag);
                    const result = new Message_1.Message(resultMsg.content, resultMsg.properties);
                    result.fields = resultMsg.fields;
                    resolve(result);
                }, { noAck: true }, (err, ok) => {
                    /* istanbul ignore if */
                    if (err) {
                        reject(new Error("amqp-ts: Queue.rpc error: " + err.message));
                    }
                    else {
                        // send the rpc request
                        consumerTag = ok.consumerTag;
                        const message = new Message_1.Message(requestParameters, {
                            replyTo: amqp_ts_1.DIRECT_REPLY_TO_QUEUE,
                        });
                        message.sendTo(this);
                    }
                });
            };
            this.initialized.then(processRpc);
        });
    }
    /**
     * Sets the prefetch of the current quere. This limits the amount of unacknowledged messages on a channel. If you
     * already specified this in the options in the constructor you don't need to set it here again.
     *
     * For more information see {@link https://www.rabbitmq.com/consumer-prefetch.html}.
     * @param count The maximum number of unacknowledged messages send to each listener of this queue.
     */
    prefetch(count) {
        this.initialized.then(() => {
            this._channel.prefetch(count);
            this.options.prefetch = count;
        });
    }
    recover() {
        return new Promise((resolve, reject) => {
            this.initialized.then(() => {
                this._channel.recover((err, _ok) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(null);
                    }
                });
            });
        });
    }
    /**
     * Actives a consumer by binding the given handler to this queue.
     *
     * @param onMessage The message handler that is executed when a new message arrives.
     * @param options Options for underlying amqplib. See
     * {@link https://www.squaremobius.net/amqp.node/channel_api.html#channel_consume} for more info. You can also
     * specify AMQP properties to set on reply messages that are fired when the given onMessage handler returns anything.
     * @throws {Error} Rejects when a consumer is already bound to this queue.
     * @returns A promise that resolves once the handler is bound to the queue.
     */
    activateConsumer(onMessage, options = {}) {
        if (this._consumerInitialized !== undefined) {
            return Promise.reject(new Error("amqp-ts Queue.activateConsumer error: consumer already defined"));
        }
        this._consumerOptions = options;
        this._consumer = onMessage;
        this._initializeConsumer();
        return this._consumerInitialized;
    }
    /**
     * Initializes the consumer with a handler function. Resolves the @see _consumerInitialized promise once the handler
     * is bound.
     */
    _initializeConsumer() {
        const activateConsumerWrapper = (msg) => {
            try {
                const message = new Message_1.Message(msg.content, msg.properties);
                message.fields = msg.fields;
                message._message = msg;
                message._channel = this._channel;
                const result = this._consumer(message);
                // convert the result to a promise if it isn't one already
                Promise.resolve(result)
                    .then((resultValue) => {
                    var _a;
                    // check if there is a reply-to
                    if (msg.properties.replyTo && resultValue) {
                        if (!(resultValue instanceof Message_1.Message)) {
                            resultValue = new Message_1.Message(resultValue, (_a = this._consumerOptions.properties) !== null && _a !== void 0 ? _a : {});
                        }
                        resultValue.properties.correlationId = msg.properties.correlationId;
                        this.log.debug("Replying directly to queue %s", msg.properties.replyTo);
                        this._channel.sendToQueue(msg.properties.replyTo, resultValue.content, resultValue.properties);
                    }
                })
                    .catch((err) => {
                    this.log.error({ err, correlationId: msg.properties.correlationId, consumerTag: msg.fields.consumerTag }, "Replying on message %s throw an error: %s", msg.properties.correlationId, err.message);
                });
            }
            catch (err) {
                /* istanbul ignore next */
                this.log.error({ err, correlationId: msg.properties.correlationId, consumerTag: msg.fields.consumerTag }, "Consuming the message %s returned error: %s", msg.properties.correlationId, err.message);
            }
        };
        this._consumerInitialized = new Promise((resolve, reject) => {
            this.initialized.then(() => {
                this._channel.consume(this._name, activateConsumerWrapper, this._consumerOptions, (err, ok) => {
                    /* istanbul ignore if */
                    if (err) {
                        reject(err);
                    }
                    else {
                        this._consumerTag = ok.consumerTag;
                        resolve(ok);
                    }
                });
            });
        });
    }
    /**
     * Completely removes the consumer handler and cancels the channel.
     */
    stopConsumer() {
        if (this._consumerStopping || this._consumerInitialized == undefined) {
            return Promise.resolve();
        }
        this._consumerStopping = true;
        return new Promise((resolve, reject) => {
            this._consumerInitialized.then(() => {
                this._channel.cancel(this._consumerTag, (err, _ok) => {
                    /* istanbul ignore if */
                    if (err) {
                        reject(err);
                    }
                    else {
                        delete this._consumerInitialized;
                        delete this._consumer;
                        delete this._consumerOptions;
                        delete this._consumerStopping;
                        resolve();
                    }
                });
            });
        });
    }
    /**
     * Removes any bindings of this queue, the consumer handler and then deletes the queue.
     */
    delete() {
        if (this._deleting === undefined) {
            this._deleting = new Promise((resolve, reject) => {
                this.initialized
                    .then(() => {
                    return Binding_1.Binding.removeBindingsContaining(this);
                })
                    .then(() => {
                    return this.stopConsumer();
                })
                    .then(() => {
                    return this._channel.deleteQueue(this._name, {}, (deleteQueueError, ok) => {
                        /* istanbul ignore if */
                        if (deleteQueueError) {
                            reject(deleteQueueError);
                        }
                        else {
                            delete this.initialized; // invalidate queue
                            delete this.connection._queues[this._name]; // remove the queue from our administration
                            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                            this._channel.removeListener("delivery", this.handleReceivedMessageEvent.bind(this));
                            this._channel.close((channelCloseError) => {
                                /* istanbul ignore if */
                                if (channelCloseError) {
                                    reject(channelCloseError);
                                }
                                else {
                                    delete this._channel;
                                    delete this.connection;
                                    resolve(ok);
                                }
                            });
                        }
                    });
                })
                    .catch((err) => {
                    reject(err);
                });
            });
        }
        return this._deleting;
    }
    /**
     * Remoevs bindings of this queue as well as the consumer handler and then closes the AMQP channel.
     */
    close() {
        if (this._closing === undefined) {
            this._closing = new Promise((resolve, reject) => {
                this.initialized
                    .then(() => {
                    return Binding_1.Binding.removeBindingsContaining(this);
                })
                    .then(() => {
                    return this.stopConsumer();
                })
                    .then(() => {
                    delete this.initialized; // invalidate queue
                    delete this.connection._queues[this._name]; // remove the queue from our administration
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                    this._channel.removeListener("delivery", this.handleReceivedMessageEvent.bind(this));
                    this._channel.close((err) => {
                        /* istanbul ignore if */
                        if (err) {
                            reject(err);
                        }
                        else {
                            delete this._channel;
                            delete this.connection;
                            resolve(null);
                        }
                    });
                })
                    .catch((err) => {
                    reject(err);
                });
            });
        }
        return this._closing;
    }
    /**
     * Binds the queue to the given exchange.
     *
     * @param source The exchange on which to bind the queue.
     * @param pattern The pattern to use.
     * @param args Any arguments.
     */
    bind(source, pattern = "", args = {}) {
        const binding = new Binding_1.Binding(this, source, pattern, args);
        return binding.initialized;
    }
    /**
     * Unbinds the queue from the given exchange by deleting the binding.
     *
     * @param source The exchange to unbind from.
     * @param pattern The pattern the queue was bind with.
     * @param _args Any additional arguments.
     */
    unbind(source, pattern = "", _args = {}) {
        return this.connection._bindings[Binding_1.Binding.id(this, source, pattern)].delete();
    }
    handleReceivedMessageEvent(_args) {
        this.connection._increaseCounter("receivedMessages");
    }
}
exports.Queue = Queue;
//# sourceMappingURL=Queue.js.map