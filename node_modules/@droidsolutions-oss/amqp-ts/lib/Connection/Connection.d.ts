/// <reference types="node" />
import * as AmqpLib from "amqplib/callback_api";
import { EventEmitter } from "events";
import { Binding } from "../Binding";
import { DeclarationOptions as ExchangeDeclarationOptions } from "../Exchange/DeclarationOptions";
import { Exchange } from "../Exchange/Exchange";
import { ExchangeType } from "../Exchange/ExchangeType";
import { LoggerFactory } from "../LoggerFactory";
import { DeclarationOptions as QueueDeclarationOptions } from "../Queue/DeclarationOptions";
import { Queue } from "../Queue/Queue";
import { ConnectionMetrics } from "./ConnectionMetrics";
import { ReconnectStrategy } from "./ReconnectStrategy";
import { Topology } from "./Topology";
export declare class Connection extends EventEmitter {
    loggerFactory?: LoggerFactory;
    initialized: Promise<void>;
    connection: AmqpLib.Connection;
    isConnected: boolean;
    _exchanges: {
        [id: string]: Exchange;
    };
    _queues: {
        [id: string]: Queue;
    };
    _bindings: {
        [id: string]: Binding;
    };
    private url;
    private socketOptions;
    private reconnectStrategy;
    private connectedBefore;
    private _retry;
    private _rebuilding;
    private _isClosing;
    private log;
    private _sentMessagesCounter;
    private _receivedMessagesCounter;
    /**
     *
     * @param url The url to RabbitMQ
     * @param socketOptions Socket options are passed to {@link AmqpLib.connect}.
     * @param reconnectStrategy Options specifying the reconnect strategy.
     * @param loggerFactory A factory function that returns a logger.
     */
    constructor(url?: string, socketOptions?: any, reconnectStrategy?: ReconnectStrategy, loggerFactory?: LoggerFactory);
    tryToConnect(thisConnection: Connection, retry: number, callback: (err: any) => void): void;
    _rebuildAll(err: Error): Promise<void>;
    close(): Promise<void>;
    /**
     * Make sure the whole defined connection topology is configured. Goes through each exchange, queue and binding and
     * waits until all of them are initialized.
     *
     * @return A promise that fulfills after all defined exchanges, queues and bindings are initialized.
     */
    completeConfiguration(): Promise<any>;
    /**
     * Delete the whole defined connection topology:
     * return promise that fulfills after all defined exchanges, queues and bindings have been removed
     */
    deleteConfiguration(): Promise<any>;
    /**
     * Declares a new exchange. Dependent on the options it auto creates the exchange if it does not already exists.
     *
     * @param name The name of the exchange.
     * @param type The type
     * @param options Options that are passed to assertExchange in amqp-lib.
     * @returns The declared queue. You need to await the initialization of the queue.
     */
    declareExchange(name: string, type?: ExchangeType, options?: ExchangeDeclarationOptions): Exchange;
    /**
     * Declares an exchange and waits until it is initialized.
     *
     * @param name The name of the exchange.
     * @param type The exchange type.
     * @param options Any declaration options.
     * @returns A promise that resolves when the exchange is declared and initialized.
     */
    declareExchangeAsync(name: string, type?: ExchangeType, options?: ExchangeDeclarationOptions): Promise<Exchange>;
    /**
     * Declares a new queue.
     *
     * @param name The name of the queue.
     * @param options Any options for the queue declaration.
     * @returns The queue.
     */
    declareQueue(name: string, options?: QueueDeclarationOptions): Queue;
    /**
     * Declares a new queue and waits until it is intitialized.
     *
     * @param name The name of the queue.
     * @param options Any options for the queue declaration.
     * @returns A promise that resolves when the queue is declared and initialized.
     */
    declareQueueAsync(name: string, options?: QueueDeclarationOptions): Promise<Queue>;
    declareTopology(topology: Topology): Promise<any>;
    get getConnection(): AmqpLib.Connection;
    /**
     * Returns an object with metrics about the connection.
     * @returns An object containing metrics about the connection.
     */
    getMetrics(): ConnectionMetrics;
    private rebuildConnection;
    /**
     * Increments an internal counter.
     * @param counter The counter to increase.
     * @param value The increment, default is 1.
     */
    _increaseCounter(counter: "receivedMessages" | "sentMessages", value?: number): void;
}
