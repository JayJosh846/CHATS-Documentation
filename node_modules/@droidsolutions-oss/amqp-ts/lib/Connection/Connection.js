"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Connection = void 0;
const AmqpLib = require("amqplib/callback_api");
const events_1 = require("events");
const Exchange_1 = require("../Exchange/Exchange");
const LoggerFactory_1 = require("../LoggerFactory");
const Queue_1 = require("../Queue/Queue");
class Connection extends events_1.EventEmitter {
    /**
     *
     * @param url The url to RabbitMQ
     * @param socketOptions Socket options are passed to {@link AmqpLib.connect}.
     * @param reconnectStrategy Options specifying the reconnect strategy.
     * @param loggerFactory A factory function that returns a logger.
     */
    constructor(url = "amqp://localhost", socketOptions = {}, reconnectStrategy = { retries: 0, interval: 1500 }, loggerFactory) {
        super();
        this.loggerFactory = loggerFactory;
        this.isConnected = false;
        this.connectedBefore = false;
        this._rebuilding = false;
        this._isClosing = false;
        this._sentMessagesCounter = 0;
        this._receivedMessagesCounter = 0;
        if (!this.loggerFactory) {
            this.loggerFactory = (_, __) => new LoggerFactory_1.EmtpyLogger();
        }
        this.log = this.loggerFactory(this.constructor, { module: "amqp-ts" });
        this.url = url;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        this.socketOptions = socketOptions;
        this.reconnectStrategy = reconnectStrategy;
        this._exchanges = {};
        this._queues = {};
        this._bindings = {};
        this.rebuildConnection();
    }
    tryToConnect(thisConnection, retry, callback) {
        AmqpLib.connect(thisConnection.url, thisConnection.socketOptions, (err, connection) => {
            /* istanbul ignore if */
            if (err) {
                thisConnection.isConnected = false;
                // only do every retry once, amqplib can return multiple connection errors for one connection request (error?)
                if (retry <= this._retry) {
                    //amqpts_log.log("warn" , "Double retry " + retry + ", skipping.", {module: "amqp-ts"});
                    return;
                }
                this.log.warn({ err }, "Connection failed.");
                this._retry = retry;
                if (thisConnection.reconnectStrategy.retries === 0 || thisConnection.reconnectStrategy.retries > retry) {
                    this.log.warn("Connection retry %d in %d ms", retry + 1, thisConnection.reconnectStrategy.interval);
                    thisConnection.emit("trying_connect");
                    setTimeout(
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                    thisConnection.tryToConnect.bind(this), thisConnection.reconnectStrategy.interval, thisConnection, retry + 1, callback);
                }
                else {
                    //no reconnect strategy, or retries exhausted, so return the error
                    this.log.warn("Connection failed, exiting: No connection retries left (retry %d).", retry);
                    callback(err);
                }
            }
            else {
                const restart = (err) => {
                    this.log.debug({ err }, "Connection error occurred.");
                    connection.removeListener("error", restart);
                    //connection.removeListener("end", restart); // not sure this is needed
                    thisConnection._rebuildAll(err); //try to rebuild the topology when the connection  unexpectedly closes
                };
                const onClose = () => {
                    connection.removeListener("close", onClose);
                    if (!this._isClosing) {
                        thisConnection.emit("lost_connection");
                        restart(new Error("Connection closed by remote host"));
                    }
                };
                connection.on("error", restart);
                connection.on("close", onClose);
                //connection.on("end", restart); // not sure this is needed
                thisConnection.connection = connection;
                thisConnection.isConnected = true;
                callback(null);
            }
        });
    }
    _rebuildAll(err) {
        this.log.warn({ err }, "Connection error: %s", err.message);
        this.log.debug("Rebuilding connection NOW.");
        this.rebuildConnection();
        //re initialize exchanges, queues and bindings if they exist
        for (const exchangeId in this._exchanges) {
            const exchange = this._exchanges[exchangeId];
            this.log.debug("Re-initialize Exchange '%s'.", exchange.name);
            exchange._initialize();
        }
        for (const queueId in this._queues) {
            const queue = this._queues[queueId];
            const consumer = queue._consumer;
            this.log.debug("Re-initialize queue '%s'.", queue.name);
            queue._initialize();
            if (consumer) {
                this.log.debug("Re-initialize consumer for queue '%s'.", queue.name);
                queue._initializeConsumer();
            }
        }
        for (const bindingId in this._bindings) {
            const binding = this._bindings[bindingId];
            this.log.debug("Re-initialize binding from '%s' to '%s'.", binding._source.name, binding._destination.name);
            binding._initialize();
        }
        return new Promise((resolve, reject) => {
            this.completeConfiguration().then(() => {
                this.log.debug("Rebuild success.");
                resolve(null);
            }, 
            /* istanbul ignore next */ (rejectReason) => {
                this.log.debug("Rebuild failed.");
                reject(rejectReason);
            });
        });
    }
    close() {
        this._isClosing = true;
        return new Promise((resolve, reject) => {
            this.initialized.then(() => {
                this.connection.close((err) => {
                    /* istanbul ignore if */
                    if (err) {
                        reject(err);
                    }
                    else {
                        this.isConnected = false;
                        this.emit("close_connection");
                        resolve(null);
                    }
                });
            });
        });
    }
    /**
     * Make sure the whole defined connection topology is configured. Goes through each exchange, queue and binding and
     * waits until all of them are initialized.
     *
     * @return A promise that fulfills after all defined exchanges, queues and bindings are initialized.
     */
    completeConfiguration() {
        const promises = [];
        for (const exchangeId in this._exchanges) {
            const exchange = this._exchanges[exchangeId];
            promises.push(exchange.initialized);
        }
        for (const queueId in this._queues) {
            const queue = this._queues[queueId];
            promises.push(queue.initialized);
            if (queue._consumerInitialized !== undefined) {
                promises.push(queue._consumerInitialized);
            }
        }
        for (const bindingId in this._bindings) {
            const binding = this._bindings[bindingId];
            promises.push(binding.initialized);
        }
        return Promise.all(promises);
    }
    /**
     * Delete the whole defined connection topology:
     * return promise that fulfills after all defined exchanges, queues and bindings have been removed
     */
    deleteConfiguration() {
        const promises = [];
        for (const bindingId in this._bindings) {
            const binding = this._bindings[bindingId];
            promises.push(binding.delete());
        }
        for (const queueId in this._queues) {
            const queue = this._queues[queueId];
            if (queue._consumerInitialized !== undefined) {
                promises.push(queue.stopConsumer());
            }
            promises.push(queue.delete());
        }
        for (const exchangeId in this._exchanges) {
            const exchange = this._exchanges[exchangeId];
            promises.push(exchange.delete());
        }
        return Promise.all(promises);
    }
    /**
     * Declares a new exchange. Dependent on the options it auto creates the exchange if it does not already exists.
     *
     * @param name The name of the exchange.
     * @param type The type
     * @param options Options that are passed to assertExchange in amqp-lib.
     * @returns The declared queue. You need to await the initialization of the queue.
     */
    declareExchange(name, type, options) {
        let exchange = this._exchanges[name];
        if (exchange === undefined) {
            exchange = new Exchange_1.Exchange(this, name, type, options);
        }
        return exchange;
    }
    /**
     * Declares an exchange and waits until it is initialized.
     *
     * @param name The name of the exchange.
     * @param type The exchange type.
     * @param options Any declaration options.
     * @returns A promise that resolves when the exchange is declared and initialized.
     */
    async declareExchangeAsync(name, type, options) {
        const exchange = this.declareExchange(name, type, options);
        await exchange.initialized;
        return exchange;
    }
    /**
     * Declares a new queue.
     *
     * @param name The name of the queue.
     * @param options Any options for the queue declaration.
     * @returns The queue.
     */
    declareQueue(name, options) {
        let queue = this._queues[name];
        if (queue === undefined) {
            queue = new Queue_1.Queue(this, name, options);
        }
        return queue;
    }
    /**
     * Declares a new queue and waits until it is intitialized.
     *
     * @param name The name of the queue.
     * @param options Any options for the queue declaration.
     * @returns A promise that resolves when the queue is declared and initialized.
     */
    async declareQueueAsync(name, options) {
        const queue = this.declareQueue(name, options);
        await queue.initialized;
        return queue;
    }
    declareTopology(topology) {
        const promises = [];
        let i;
        let len;
        if (topology.exchanges !== undefined) {
            for (i = 0, len = topology.exchanges.length; i < len; i++) {
                const exchange = topology.exchanges[i];
                promises.push(this.declareExchange(exchange.name, exchange.type, exchange.options)
                    .initialized);
            }
        }
        if (topology.queues !== undefined) {
            for (i = 0, len = topology.queues.length; i < len; i++) {
                const queue = topology.queues[i];
                promises.push(this.declareQueue(queue.name, queue.options).initialized);
            }
        }
        if (topology.bindings !== undefined) {
            for (i = 0, len = topology.bindings.length; i < len; i++) {
                const binding = topology.bindings[i];
                const source = this.declareExchange(binding.source);
                let destination;
                if (binding.exchange !== undefined) {
                    destination = this.declareExchange(binding.exchange);
                }
                else {
                    destination = this.declareQueue(binding.queue);
                }
                promises.push(destination.bind(source, binding.pattern, binding.args));
            }
        }
        return Promise.all(promises);
    }
    get getConnection() {
        return this.connection;
    }
    /**
     * Returns an object with metrics about the connection.
     * @returns An object containing metrics about the connection.
     */
    getMetrics() {
        return {
            receivedMessagesCounter: this._receivedMessagesCounter,
            sentMessagesCounter: this._sentMessagesCounter,
        };
    }
    rebuildConnection() {
        if (this._rebuilding) {
            // only one rebuild process can be active at any time
            this.log.debug("AMQP Connection rebuild already in progress, joining active rebuild attempt.");
            return this.initialized;
        }
        this._retry = -1;
        this._rebuilding = true;
        this._isClosing = false;
        // rebuild the connection
        this.initialized = new Promise((resolve, reject) => {
            this.tryToConnect(this, 0, (err) => {
                /* istanbul ignore if */
                if (err) {
                    this._rebuilding = false;
                    reject(err);
                }
                else {
                    this._rebuilding = false;
                    if (this.connectedBefore) {
                        this.log.info("AMQP Connection re-established");
                        this.emit("re_established_connection");
                    }
                    else {
                        this.log.info("AQMP Connection established.");
                        this.emit("open_connection");
                        this.connectedBefore = true;
                    }
                    resolve(null);
                }
            });
        });
        /* istanbul ignore next */
        this.initialized.catch((err) => {
            this.log.warn({ err }, "Error creating connection!");
            this.emit("error_connection", err);
            //throw (err);
        });
        return this.initialized;
    }
    /**
     * Increments an internal counter.
     * @param counter The counter to increase.
     * @param value The increment, default is 1.
     */
    _increaseCounter(counter, value = 1) {
        switch (counter) {
            case "receivedMessages":
                this._receivedMessagesCounter += value;
                break;
            case "sentMessages":
                this._sentMessagesCounter += value;
                break;
        }
    }
}
exports.Connection = Connection;
//# sourceMappingURL=Connection.js.map