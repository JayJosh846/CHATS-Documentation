"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Binding = void 0;
const Queue_1 = require("./Queue/Queue");
class Binding {
    static id(destination, source, pattern) {
        pattern = pattern || "";
        return ("[" +
            source.name +
            "]to" +
            (destination instanceof Queue_1.Queue ? "Queue" : "Exchange") +
            "[" +
            destination.name +
            "]" +
            pattern);
    }
    static removeBindingsContaining(connectionPoint) {
        const connection = connectionPoint.connection;
        const promises = [];
        for (const bindingId in connection._bindings) {
            const binding = connection._bindings[bindingId];
            if (binding._source === connectionPoint || binding._destination === connectionPoint) {
                promises.push(binding.delete());
            }
        }
        return Promise.all(promises);
    }
    constructor(destination, source, pattern = "", args = {}) {
        this.pattern = pattern;
        this.args = args;
        this.log = destination.connection.loggerFactory(this.constructor);
        this._source = source;
        this._destination = destination;
        this._destination.connection._bindings[Binding.id(this._destination, this._source, this.pattern)] = this;
        this._initialize();
    }
    _initialize() {
        this.initialized = new Promise((resolve, reject) => {
            if (this._destination instanceof Queue_1.Queue) {
                const queue = this._destination;
                queue.initialized.then(() => {
                    queue._channel.bindQueue(this._destination.name, this._source.name, this.pattern, this.args, (err, _ok) => {
                        /* istanbul ignore if */
                        if (err) {
                            this.log.error({ err }, "Failed to create queue binding (%s->%s)", this._source.name, this._destination.name);
                            delete this._destination.connection._bindings[Binding.id(this._destination, this._source, this.pattern)];
                            reject(err);
                        }
                        else {
                            resolve(this);
                        }
                    });
                });
            }
            else {
                const exchange = this._destination;
                exchange.initialized.then(() => {
                    exchange._channel.bindExchange(this._destination.name, this._source.name, this.pattern, this.args, (err, _ok) => {
                        /* istanbul ignore if */
                        if (err) {
                            this.log.error({ err }, "Failed to create exchange binding (%s->%s)", this._source.name, this._destination.name);
                            delete this._destination.connection._bindings[Binding.id(this._destination, this._source, this.pattern)];
                            reject(err);
                        }
                        else {
                            resolve(this);
                        }
                    });
                });
            }
        });
    }
    /**
     * Deletes this binding of either a queue or an exchange.
     */
    delete() {
        return new Promise((resolve, reject) => {
            if (this._destination instanceof Queue_1.Queue) {
                const queue = this._destination;
                queue.initialized.then(() => {
                    queue._channel.unbindQueue(this._destination.name, this._source.name, this.pattern, this.args, (err, _ok) => {
                        /* istanbul ignore if */
                        if (err) {
                            reject(err);
                        }
                        else {
                            delete this._destination.connection._bindings[Binding.id(this._destination, this._source, this.pattern)];
                            resolve(null);
                        }
                    });
                });
            }
            else {
                const exchange = this._destination;
                exchange.initialized.then(() => {
                    exchange._channel.unbindExchange(this._destination.name, this._source.name, this.pattern, this.args, (err, _ok) => {
                        /* istanbul ignore if */
                        if (err) {
                            reject(err);
                        }
                        else {
                            delete this._destination.connection._bindings[Binding.id(this._destination, this._source, this.pattern)];
                            resolve(null);
                        }
                    });
                });
            }
        });
    }
}
exports.Binding = Binding;
//# sourceMappingURL=Binding.js.map