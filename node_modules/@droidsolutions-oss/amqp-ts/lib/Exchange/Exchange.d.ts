import * as AmqpLib from "amqplib/callback_api";
import { Binding } from "../Binding";
import { Connection } from "../Connection/Connection";
import { Message } from "../Message";
import { DeclarationOptions } from "./DeclarationOptions";
import { ExchangeType } from "./ExchangeType";
import { InitializeResult } from "./InitializeResult";
/**
 * Represents an exchange.
 */
export declare class Exchange {
    connection: Connection;
    private options;
    /** A promise that resolves once the exchange is initialized. */
    initialized: Promise<InitializeResult>;
    /** The underlying AMQP channel. */
    _channel: AmqpLib.Channel;
    /** Gets the name of the exchange. */
    get name(): string;
    /** Gets the type of the exchange. */
    get type(): string;
    private _consumer_handlers;
    private _isConsumerInitializedRcp;
    private _name;
    private _type;
    private _deleting;
    private _closing;
    private log;
    /**
     * Initializes a new instance of the @see Exchange class.
     *
     * @summary Initializes an exchange by creating a channel and asserting the exchange exists on it. Once done the
     * {@link initialized} promise will resolve.
     * @param connection The AMQP connection.
     * @param name The name of the exchange.
     * @param type The type of the exchange.
     * @param options Any declaration otions.
     */
    constructor(connection: Connection, name: string, type?: ExchangeType, options?: DeclarationOptions);
    /**
     * Initializes the exchange and resolves the @see initialized promise once the initialization is complete.
     */
    _initialize(): void;
    /**
     * Directly sends a message to this exchange.
     *
     * @param message The message.
     * @param routingKey The routing key of the message.
     */
    send(message: Message, routingKey?: string): void;
    rpc(requestParameters: any, routingKey?: string, callback?: (err: any, message: Message) => void): Promise<Message>;
    /**
     * Removes any bindings of this exchange, deletes the exchange and then closes the channel.
     */
    delete(): Promise<void>;
    /**
     * Removes any bindings of this exchange and closes the channel.
     */
    close(): Promise<void>;
    /**
     * Creates a bew binding with this exchange to the given exchange.
     *
     * @param source The source exchange.
     * @param pattern The pattern.
     * @param args Any additonal arguments.
     * @returns A promise that resolves when the binding is initialized.
     */
    bind(source: Exchange, pattern?: string, args?: any): Promise<Binding>;
    /**
     * Unbinds the given exchange from the connection.
     *
     * @param source The exchange to unbind from.
     * @param pattern The pattern.
     * @param _args Any addtional arguments.
     */
    unbind(source: Exchange, pattern?: string, _args?: any): Promise<void>;
    /** Returns a string containing the name of the exchange, the name of the host and the process ID. */
    consumerQueueName(): string;
    /**
     * Declares a queue, binds it to this exchange and activates the given consumer handler on the queue. The name of the
     * queue is determined by the name of the exchange, the application, the host and the ID of the process. Calling this
     * twice without @see stopConsumer between the calls will likely fail.
     *
     * @param onMessage The message handler.
     * @param options Any consumer options. See
     * @link https://www.squaremobius.net/amqp.node/channel_api.html#channel_consume for more information.
     * @throws {Error} If a handler has already been registered for this queue.
     */
    activateConsumer(onMessage: (msg: Message) => any, options?: AmqpLib.Options.Consume): Promise<any>;
    /**
     * Removes the bindings, the consumer and the queue if any exists.
     */
    stopConsumer(): Promise<any>;
}
