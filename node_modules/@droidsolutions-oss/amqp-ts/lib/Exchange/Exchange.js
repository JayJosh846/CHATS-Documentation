"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Exchange = void 0;
const os = require("os");
const amqp_ts_1 = require("../amqp-ts");
const Binding_1 = require("../Binding");
const Message_1 = require("../Message");
/**
 * Represents an exchange.
 */
class Exchange {
    /** Gets the name of the exchange. */
    get name() {
        return this._name;
    }
    /** Gets the type of the exchange. */
    get type() {
        return this._type;
    }
    /**
     * Initializes a new instance of the @see Exchange class.
     *
     * @summary Initializes an exchange by creating a channel and asserting the exchange exists on it. Once done the
     * {@link initialized} promise will resolve.
     * @param connection The AMQP connection.
     * @param name The name of the exchange.
     * @param type The type of the exchange.
     * @param options Any declaration otions.
     */
    constructor(connection, name, type, options = {}) {
        this.connection = connection;
        this.options = options;
        this._consumer_handlers = new Array();
        this._isConsumerInitializedRcp = false;
        this.log = this.connection.loggerFactory(this.constructor, { exchange: name });
        this._name = name;
        this._type = type;
        this._initialize();
    }
    /**
     * Initializes the exchange and resolves the @see initialized promise once the initialization is complete.
     */
    _initialize() {
        this.initialized = new Promise((resolve, reject) => {
            this.connection.initialized
                .then(() => {
                this.connection.connection.createChannel((createChannelError, channel) => {
                    /* istanbul ignore if */
                    if (createChannelError) {
                        reject(createChannelError);
                    }
                    else {
                        this._channel = channel;
                        const callback = (err, ok) => {
                            /* istanbul ignore if */
                            if (err) {
                                this.log.error({ err }, "Failed to create exchange '%s'.", this._name);
                                delete this.connection._exchanges[this._name];
                                reject(err);
                            }
                            else {
                                resolve(ok);
                            }
                        };
                        if (this.options.noCreate) {
                            this._channel.checkExchange(this._name, callback);
                        }
                        else {
                            this._channel.assertExchange(this._name, this._type, this.options, callback);
                        }
                    }
                });
            })
                .catch((err) => {
                this.log.warn({ err }, "Channel failure, error caused during connection!");
            });
        });
        this.connection._exchanges[this._name] = this;
    }
    /**
     * Directly sends a message to this exchange.
     *
     * @param message The message.
     * @param routingKey The routing key of the message.
     */
    send(message, routingKey = "") {
        message.sendTo(this, routingKey);
    }
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    rpc(requestParameters, routingKey = "", callback) {
        return new Promise((resolve, reject) => {
            function generateUuid() {
                return Math.random().toString() + Math.random().toString() + Math.random().toString();
            }
            const processRpc = () => {
                const uuid = generateUuid();
                if (!this._isConsumerInitializedRcp) {
                    this._isConsumerInitializedRcp = true;
                    this._channel.consume(amqp_ts_1.DIRECT_REPLY_TO_QUEUE, (resultMsg) => {
                        const result = new Message_1.Message(resultMsg.content, resultMsg.properties);
                        result.fields = resultMsg.fields;
                        for (const handler of this._consumer_handlers) {
                            if (handler[0] === resultMsg.properties.correlationId) {
                                const func = handler[1];
                                func.apply("", [undefined, result]);
                            }
                        }
                        resolve(result);
                    }, { noAck: true }, (err, _ok) => {
                        /* istanbul ignore if */
                        if (err) {
                            reject(new Error("amqp-ts: Queue.rpc error: " + err.message));
                        }
                        else {
                            if (callback) {
                                // send the rpc request
                                this._consumer_handlers.push([uuid, callback]);
                            }
                            // consumerTag = ok.consumerTag;
                            const message = new Message_1.Message(requestParameters, {
                                correlationId: uuid,
                                replyTo: amqp_ts_1.DIRECT_REPLY_TO_QUEUE,
                            });
                            message.sendTo(this, routingKey);
                        }
                    });
                }
                else {
                    this._consumer_handlers.push([uuid, callback]);
                    const message = new Message_1.Message(requestParameters, {
                        correlationId: uuid,
                        replyTo: amqp_ts_1.DIRECT_REPLY_TO_QUEUE,
                    });
                    message.sendTo(this, routingKey);
                    resolve(message);
                }
            };
            this.initialized.then(processRpc);
        });
    }
    /**
     * Removes any bindings of this exchange, deletes the exchange and then closes the channel.
     */
    delete() {
        if (this._deleting === undefined) {
            this._deleting = new Promise((resolve, reject) => {
                this.initialized
                    .then(() => {
                    return Binding_1.Binding.removeBindingsContaining(this);
                })
                    .then(() => {
                    this._channel.deleteExchange(this._name, {}, (deleteExchangeError, _ok) => {
                        /* istanbul ignore if */
                        if (deleteExchangeError) {
                            reject(deleteExchangeError);
                        }
                        else {
                            this._channel.close((channelCloseError) => {
                                delete this.initialized; // invalidate exchange
                                delete this.connection._exchanges[this._name]; // remove the exchange from our administration
                                /* istanbul ignore if */
                                if (channelCloseError) {
                                    reject(channelCloseError);
                                }
                                else {
                                    delete this._channel;
                                    delete this.connection;
                                    resolve(null);
                                }
                            });
                        }
                    });
                })
                    .catch((err) => {
                    reject(err);
                });
            });
        }
        return this._deleting;
    }
    /**
     * Removes any bindings of this exchange and closes the channel.
     */
    close() {
        if (this._closing === undefined) {
            this._closing = new Promise((resolve, reject) => {
                this.initialized
                    .then(() => {
                    return Binding_1.Binding.removeBindingsContaining(this);
                })
                    .then(() => {
                    delete this.initialized; // invalidate exchange
                    delete this.connection._exchanges[this._name]; // remove the exchange from our administration
                    this._channel.close((err) => {
                        /* istanbul ignore if */
                        if (err) {
                            reject(err);
                        }
                        else {
                            delete this._channel;
                            delete this.connection;
                            resolve(null);
                        }
                    });
                })
                    .catch((err) => {
                    reject(err);
                });
            });
        }
        return this._closing;
    }
    /**
     * Creates a bew binding with this exchange to the given exchange.
     *
     * @param source The source exchange.
     * @param pattern The pattern.
     * @param args Any additonal arguments.
     * @returns A promise that resolves when the binding is initialized.
     */
    bind(source, pattern = "", args = {}) {
        const binding = new Binding_1.Binding(this, source, pattern, args);
        return binding.initialized;
    }
    /**
     * Unbinds the given exchange from the connection.
     *
     * @param source The exchange to unbind from.
     * @param pattern The pattern.
     * @param _args Any addtional arguments.
     */
    unbind(source, pattern = "", _args = {}) {
        return this.connection._bindings[Binding_1.Binding.id(this, source, pattern)].delete();
    }
    /** Returns a string containing the name of the exchange, the name of the host and the process ID. */
    consumerQueueName() {
        return `${this._name}.${amqp_ts_1.ApplicationName}.${os.hostname()}.${process.pid}`;
    }
    /**
     * Declares a queue, binds it to this exchange and activates the given consumer handler on the queue. The name of the
     * queue is determined by the name of the exchange, the application, the host and the ID of the process. Calling this
     * twice without @see stopConsumer between the calls will likely fail.
     *
     * @param onMessage The message handler.
     * @param options Any consumer options. See
     * @link https://www.squaremobius.net/amqp.node/channel_api.html#channel_consume for more information.
     * @throws {Error} If a handler has already been registered for this queue.
     */
    activateConsumer(onMessage, options) {
        const queueName = this.consumerQueueName();
        if (this.connection._queues[queueName]) {
            return Promise.reject(new Error("amqp-ts Exchange.activateConsumer error: consumer already defined"));
        }
        else {
            const promises = [];
            const queue = this.connection.declareQueue(queueName, { durable: false });
            promises.push(queue.initialized);
            const binding = queue.bind(this);
            promises.push(binding);
            const consumer = queue.activateConsumer(onMessage, options);
            promises.push(consumer);
            return Promise.all(promises);
        }
    }
    /**
     * Removes the bindings, the consumer and the queue if any exists.
     */
    stopConsumer() {
        const queue = this.connection._queues[this.consumerQueueName()];
        if (queue) {
            return queue.delete();
        }
        else {
            return Promise.resolve();
        }
    }
}
exports.Exchange = Exchange;
//# sourceMappingURL=Exchange.js.map