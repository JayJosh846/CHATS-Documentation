/// <reference types="node" />
import * as AmqpLib from "amqplib/callback_api";
import { AmqpProperties } from "./AmqpProperties";
import { Exchange } from "./Exchange/Exchange";
import { Queue } from "./Queue/Queue";
/**
 * Represents a message that can be send via AMQP.
 */
export declare class Message {
    fields: any;
    /** for received messages only: the channel it has been received on */
    _channel: AmqpLib.Channel;
    /** received messages only: original amqplib message */
    _message: AmqpLib.Message;
    /** Additional AQMP properties of the message. */
    properties: AmqpProperties;
    /** The original contant of the message. */
    content: Buffer;
    /**
     * Initializes a new instance of the @see Message class.
     *
     * If the given content is not a buffer or a string it will be converted to a json string and the content type will be
     * set.
     *
     * @param content The message content.
     * @param options The message options.
     */
    constructor(content?: any, options?: AmqpProperties);
    /**
     * Returns the content of the message. If properties.contentType is set to "application/json" the content will be
     * parsed. If not it will return the string that represents the buffer.
     */
    getContent(): string | Record<string, unknown>;
    /**
     * Returns the content of the message parsed from json.
     *
     * @throws {Error} If the content type in the message properties is not set to application/json.
     */
    getJsonContent<T>(): T;
    /**
     * Tries to publish the message on the destination channel. Appends the current @see properties object and the
     * @see content of the message.
     *
     * @param destination The destination of the message.
     * @param routingKey An optional routing key.
     */
    sendTo(destination: Exchange | Queue, routingKey?: string): void;
    ack(allUpTo?: boolean): void;
    nack(allUpTo?: boolean, requeue?: boolean): void;
    reject(requeue?: boolean): void;
    private setContent;
}
