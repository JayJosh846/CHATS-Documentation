"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Message = void 0;
const Queue_1 = require("./Queue/Queue");
/**
 * Represents a message that can be send via AMQP.
 */
class Message {
    /**
     * Initializes a new instance of the @see Message class.
     *
     * If the given content is not a buffer or a string it will be converted to a json string and the content type will be
     * set.
     *
     * @param content The message content.
     * @param options The message options.
     */
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    constructor(content, options = {}) {
        this.properties = options;
        if (content !== undefined) {
            this.setContent(content);
        }
    }
    /**
     * Returns the content of the message. If properties.contentType is set to "application/json" the content will be
     * parsed. If not it will return the string that represents the buffer.
     */
    getContent() {
        let content = this.content.toString();
        if (this.properties.contentType === "application/json") {
            content = JSON.parse(content);
        }
        return content;
    }
    /**
     * Returns the content of the message parsed from json.
     *
     * @throws {Error} If the content type in the message properties is not set to application/json.
     */
    getJsonContent() {
        var _a;
        if (this.properties.contentType !== "application/json") {
            throw new Error("The content of the message is not set as application/json.");
        }
        return JSON.parse(this.content.toString((_a = this.properties.contentEncoding) !== null && _a !== void 0 ? _a : "utf-8"));
    }
    /**
     * Tries to publish the message on the destination channel. Appends the current @see properties object and the
     * @see content of the message.
     *
     * @param destination The destination of the message.
     * @param routingKey An optional routing key.
     */
    sendTo(destination, routingKey = "") {
        let exchange;
        // inline function to send the message
        const sendMessage = () => {
            try {
                if (!this.properties.timestamp) {
                    // Set timestamp if not set by user
                    this.properties.timestamp = Math.floor(new Date().getTime() / 1000);
                }
                destination._channel.publish(exchange, routingKey, this.content, this.properties);
                destination.connection._increaseCounter("sentMessages");
            }
            catch (err) {
                const log = destination.connection.loggerFactory(this.constructor);
                log.debug({ err }, "Publish error: %s", err.message);
                const destinationName = destination.name;
                const connection = destination.connection;
                log.debug("Try to rebuild connection, before Call.");
                connection._rebuildAll(err).then(() => {
                    log.debug("Retransmitting message.");
                    if (destination instanceof Queue_1.Queue) {
                        // connection._queues[destinationName].publish(this.content, this.properties);
                        connection._queues[destinationName].send(this);
                    }
                    else {
                        // connection._exchanges[destinationName].publish(this.content, routingKey, this.properties);
                        connection._exchanges[destinationName].send(this);
                    }
                });
            }
        };
        if (destination instanceof Queue_1.Queue) {
            exchange = "";
            routingKey = destination.name;
        }
        else {
            exchange = destination.name;
        }
        destination.initialized.then(sendMessage);
    }
    ack(allUpTo) {
        if (this._channel !== undefined) {
            this._channel.ack(this._message, allUpTo);
        }
    }
    nack(allUpTo, requeue) {
        if (this._channel !== undefined) {
            this._channel.nack(this._message, allUpTo, requeue);
        }
    }
    reject(requeue = false) {
        if (this._channel !== undefined) {
            this._channel.reject(this._message, requeue);
        }
    }
    setContent(content) {
        if (typeof content === "string") {
            this.content = Buffer.from(content);
        }
        else if (!(content instanceof Buffer)) {
            this.content = Buffer.from(JSON.stringify(content));
            this.properties.contentType = "application/json";
            this.properties.contentEncoding = "utf-8";
        }
        else {
            this.content = content;
        }
    }
}
exports.Message = Message;
//# sourceMappingURL=Message.js.map